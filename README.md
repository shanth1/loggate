# Документация системы LogGate

## Содержание

1.  **Общее описание системы**
    - 1.1. Назначение
    - 1.2. Ключевые особенности
2.  **Архитектура и компоненты**
    - 2.1. Схема взаимодействия
    - 2.2. Описание компонентов
3.  **Логика работы LogGate**
    - 3.1. Прием логов
    - 3.2. Маршрутизация
    - 3.3. Буферизация и пакетная обработка
    - 3.4. Сохранение и вывод
4.  **Инструкция по запуску**
    - 4.1. Локальный запуск (для разработки)
    - 4.2. Запуск в Production
5.  **Администрирование и Управление**
    - 5.1. Основные команды Docker Compose
    - 5.2. Мониторинг системы
    - 5.3. Управление данными и бэкапы (Loki)
    - 5.4. Дополнительные полезные команды

---

## 1. Общее описание системы

### 1.1. Назначение

**LogGate** — это высокопроизводительный сервис для приёма, обработки и маршрутизации логов. Он спроектирован как центральная точка входа (шлюз) для логов от различных приложений и сервисов. LogGate получает структурированные логи, определяет, куда их следует направить (например, в базу данных, систему хранения логов или просто в консоль), и отправляет их в соответствующие хранилища.

Система поставляется с полным стеком для мониторинга и визуализации на базе **Prometheus, Loki и Grafana**, что позволяет не только обрабатывать логи, но и полноценно наблюдать за их потоком и состоянием самого сервиса.

### 1.2. Ключевые особенности

- **Централизованный прием логов:** Принимает логи по протоколу UDP, что обеспечивает низкие задержки и не блокирует отправителей.
- **Гибкая маршрутизация:** Правила в конфигурационном файле (`config.yaml`) позволяют направлять логи в разные системы хранения (storages) в зависимости от их атрибутов (например, `service` или `level`).
- **Расширяемость:** Архитектура на основе "адаптеров" позволяет легко добавлять поддержку новых хранилищ (ClickHouse, Elasticsearch и т.д.).
- **Производительность:** Написан на Go. Использует внутреннюю буферизацию и пакетную обработку для эффективной записи логов.
- **Готовый стек "из коробки":** `docker-compose.yaml` разворачивает не только сам LogGate, но и весь необходимый инструментарий для сбора, хранения, визуализации логов и метрик.
- **Инструменты для разработки:** Включает генератор логов (`loggen`) для тестирования нагрузки и отладки.

## 2. Архитектура и компоненты

### 2.1. Схема взаимодействия

```
                                      +-------------------------+
                                      |      Внешние сервисы    |
                                      +-------------------------+
                                                  |
                                                  | (UDP, JSON Logs)
                                                  v
+---------------------------------------------------------------------------------------------------+
| Docker Host                                                                                       |
|                                                                                                   |
|    +------------------------+        (stdout)         +--------------------+                      |
|    |    loggate-service     |------------------------>|      promtail      |                      |
|    | (Go App, UDP:10514)    |                         |  (Log Collector)   |                      |
|    +------------------------+                         +--------------------+                      |
|      |          ^                                               | (Logs)                        |
|      | (Metrics /metrics)                                       v                               |
|      |          |                                     +--------------------+                      |
|      +----------+------------------------------------>|        loki        |                      |
|                 |                                     |  (Log Aggregator)  |                      |
|                 v                                     +--------------------+                      |
|    +------------------------+                                   ^                               |
|    |      prometheus        |                                   | (LogQL Queries)               |
|    |   (Metrics Scraper)    |<------------------------+         |                               |
|    +------------------------+                         |         |                               |
|       ^         ^                                     |         |                               |
|       |         +-------------------------------------|---------+                               |
|       | (PromQL)                                      | (Queries)                               |
|       |                                               v                                         |
|    +------------------------+            +------------------------+                               |
|    |        grafana         |            |        cadvisor        |                               |
|    |    (Visualization)     |            | (Container Metrics)    |                               |
|    +------------------------+            +------------------------+                               |
|                                                     ^                                             |
|                                                     | (Scrape)                                    |
|                                                     +---------------------------------------------+
|                                                                                                   |
+---------------------------------------------------------------------------------------------------+
```

### 2.2. Описание компонентов

Вся система разворачивается с помощью `docker-compose.yaml` и состоит из следующих сервисов:

| Сервис                | Роль в системе                                                                                                                       | Порты                   | Ключевые файлы                     |
| :-------------------- | :----------------------------------------------------------------------------------------------------------------------------------- | :---------------------- | :--------------------------------- |
| **`loggate-service`** | **Основное приложение.** Принимает логи по UDP, маршрутизирует их и выводит в `stdout`. Экспортирует метрики для Prometheus.         | `10514/udp`, `9100/tcp` | `config/config.yaml`, `Dockerfile` |
| **`prometheus`**      | Сбор, хранение и обработка метрик. Собирает метрики с `loggate`, `loki`, `promtail` и `cadvisor`.                                    | `9090/tcp`              | `prometheus/prometheus.yaml`       |
| **`loki`**            | Система агрегации и хранения логов. Принимает логи от `promtail`.                                                                    | `3100/tcp`              | `loki/loki-config.yaml`            |
| **`promtail`**        | Агент для сбора логов. "Подхватывает" логи из `stdout` контейнера `loggate`, обогащает их метаданными (метками) и отправляет в Loki. | -                       | `promtail/promtail-config.yaml`    |
| **`grafana`**         | Платформа для визуализации. Отображает метрики из Prometheus и логи из Loki на готовом дашборде.                                     | `3000/tcp`              | `grafana/provisioning/*`           |
| **`cadvisor`**        | Собирает метрики об использовании ресурсов (CPU, memory, network) всеми Docker контейнерами.                                         | `8080/tcp`              | -                                  |

## 3. Логика работы LogGate

Основная логика приложения `loggate` сосредоточена в `internal/core/service/service.go`.

### 3.1. Прием логов

1.  **UDP Listener** (`internal/adapters/input/udp/listener.go`) запускается на порту, указанном в `server.log_address` (по умолчанию `:10514`).
2.  Он непрерывно слушает входящие UDP-пакеты.
3.  Каждый пакет рассматривается как JSON-сообщение. Система пытается десериализовать его в структуру `domain.LogMessage`.
    ```go
    type LogMessage struct {
        Timestamp time.Time              `json:"timestamp"`
        Level     string                 `json:"level"`
        Service   string                 `json:"service"`
        Message   string                 `json:"message"`
        Fields    map[string]interface{} `json:"fields,omitempty"`
    }
    ```
4.  В случае успеха, `LogMessage` передается в ядро сервиса — `LogService` — через метод `Ingest`.

### 3.2. Маршрутизация

1.  Метод `Ingest` в `LogService` определяет, куда отправить полученное сообщение.
2.  Он последовательно проверяет `routing_rules` из `config/config.yaml`.
3.  Правило считается совпавшим, если поля `service` и `level` в логе соответствуют `match_condition` в правиле.
4.  Если совпадение найдено, лог направляется в `destinations`, указанные в этом правиле (например, `["clickhouse_main"]`).
5.  Если ни одно правило не совпало, лог направляется в хранилища, перечисленные в `default_destinations` (например, `["console_debug"]`).

### 3.3. Буферизация и пакетная обработка

Чтобы избежать постоянных обращений к хранилищам на каждый лог, `LogService` использует внутренние буферы (каналы Go):

1.  Для каждого активного хранилища (`storage`) создается отдельный воркер и канал (буфер) размером `1000` сообщений.
2.  После маршрутизации лог попадает в канал соответствующего хранилища.
3.  Воркер накапливает логи из канала в "пакет" (`batch`).
4.  Пакет отправляется в хранилище, когда выполняется одно из условий:
    - Размер пакета достигает `1000` сообщений.
    - Прошло `5 секунд` с момента получения последнего сообщения (таймаут).
5.  Эта механика значительно снижает нагрузку на системы хранения и сеть.

### 3.4. Сохранение и вывод

- Логика сохранения вынесена в "адаптеры вывода" (`internal/adapters/output/*`). В текущей конфигурации активен только `console.Storage`.
- **`console.Storage`** (`internal/adapters/output/console/storage.go`) просто выводит полученный пакет логов в стандартный вывод (`stdout`) в формате JSON.
- **Ключевой момент интеграции:** `Promtail` настроен так, чтобы читать `stdout` из контейнера `loggate-service`. Он парсит этот JSON, извлекает поля `level` и `service` и превращает их в _метки_ (labels) Loki. Это делает логи в Grafana легко фильтруемыми и индексируемыми.

## 4. Инструкция по запуску

### 4.1. Локальный запуск (для разработки)

#### Шаг 1: Подготовка окружения

Убедитесь, что у вас установлены:

- Docker
- Docker Compose (обычно идет вместе с Docker Desktop)
- Go (для запуска `loggen`)
- `make` (опционально, для удобства)

#### Шаг 2: Конфигурация

1.  Склонируйте репозиторий.
2.  Создайте файл с переменными окружения для Grafana:
    ```bash
    cp .env.example .env
    ```
    Вы можете изменить пароль в файле `.env`, если требуется. По умолчанию: `admin`/`admin`.

#### Шаг 3: Сборка и запуск

Выполните команду в корневой директории проекта:

```bash
docker-compose up --build -d
```

- `--build`: принудительно пересобирает образ `loggate`, если в коде были изменения.
- `-d`: запускает контейнеры в фоновом режиме.

#### Шаг 4: Проверка состояния

Убедитесь, что все контейнеры запустились и работают:

```bash
docker-compose ps
```

Вы должны увидеть `Up` или `running` в статусе для всех сервисов (`loggate-service`, `prometheus`, `loki`, `grafana` и т.д.).

#### Шаг 5: Генерация тестовых логов

Чтобы отправить логи в `loggate`, используйте встроенный генератор:

```bash
# С помощью Makefile
make fake

# Или напрямую через Go
go run ./cmd/loggen/main.go
```

Генератор начнет отправлять логи по UDP на `localhost:10514` в соответствии с конфигурацией `cmd/loggen/config/config.yaml`.

#### Шаг 6: Доступ к интерфейсам

- **Grafana:** `http://localhost:3000`
  - Логин: `admin` (или значение `GRAFANA_ADMIN_USER` из `.env`)
  - Пароль: `admin` (или значение `GRAFANA_ADMIN_PASSWORD` из `.env`)
  - Дашборд "LogGate Application" уже будет доступен в разделе Dashboards.
- **Prometheus:** `http://localhost:9090`
  - Здесь можно выполнять запросы к метрикам (например, `go_goroutines{job="loggate"}`).
- **cAdvisor:** `http://localhost:8080`
  - Метрики по всем контейнерам.

### 4.2. Запуск в Production

Переход в продакшн требует дополнительных шагов для обеспечения безопасности, стабильности и надежности.

1.  **Конфигурация:**
    - **Пароли:** **Обязательно** смените пароль администратора Grafana в `.env` файле на сложный и уникальный.
    - **LogGate Config:** Отредактируйте `config/config.yaml`. Включите и настройте нужные вам хранилища (`clickhouse_main` и др.), указав корректные DSN (Data Source Name) с учетными данными. Не храните пароли в открытом виде, используйте переменные окружения или системы управления секретами (например, Vault).
    - **Отключите `console_debug`**, если он не нужен, чтобы не засорять логи Docker.

2.  **Управление данными:**
    - Docker-volumes (`prometheus_data`, `loki_data`, `grafana_data`) хранят данные на хост-машине. Убедитесь, что на диске достаточно места, и настройте регулярное резервное копирование этих томов (см. раздел 5.3).

3.  **Ресурсы:**
    - В `docker-compose.yaml` для продакшена рекомендуется добавить ограничения по ресурсам для каждого сервиса, чтобы избежать чрезмерного потребления CPU или памяти.

    ```yaml
    services:
      loggate:
        # ...
        deploy:
          resources:
            limits:
              cpus: '0.50'
              memory: 512M
            reservations:
              cpus: '0.25'
              memory: 256M
    ```

4.  **Сетевая безопасность:**
    - Не выставляйте порты `9090` (Prometheus), `3100` (Loki), `8080` (cAdvisor) в интернет напрямую. Доступ к ним должен быть только из доверенных сетей.
    - Для доступа к Grafana (`3000`) используйте обратный прокси (например, Nginx, Traefik) с настройкой TLS/SSL для шифрования трафика (HTTPS).

5.  **Пересборка и запуск:**
    - Перед запуском в продакшене всегда пересобирайте образы с последними изменениями:
    ```bash
    docker-compose -f docker-compose.yaml build
    docker-compose -f docker-compose.yaml up -d
    ```
    (Использование `-f` явно указывает на файл, что полезно, если у вас есть отдельные файлы для dev и prod).

## 5. Администрирование и Управление

### 5.1. Основные команды Docker Compose

Эти команды взяты из `README.md` и дополнены пояснениями.

- **Сборка и первый запуск:**
  ```bash
  docker-compose up --build -d
  ```
- **Проверка состояния всех сервисов:**
  ```bash
  docker-compose ps
  ```
- **Просмотр логов конкретного сервиса (например, `loggate`):**
  ```bash
  docker-compose logs -f loggate
  ```
- **Остановка сервисов (контейнеры остаются):**
  ```bash
  docker-compose stop
  ```
- **Запуск остановленных сервисов:**
  ```bash
  docker-compose start
  ```
- **Остановка и удаление контейнеров:**
  ```bash
  docker-compose down
  ```
- **Остановка, удаление контейнеров И УДАЛЕНИЕ ДАННЫХ (volumes):**
  ```bash
  # ОСТОРОЖНО: Эта команда удалит все сохраненные логи и метрики!
  docker-compose down -v
  ```
- **Перезапуск одного сервиса с пересборкой:**
  ```bash
  docker-compose up --build -d loggate
  ```

### 5.2. Мониторинг системы

Основной инструмент для мониторинга — дашборд в **Grafana** (`http://localhost:3000`).

**Ключевые метрики на дашборде:**

- **Total Log Rate:** Общее количество строк логов в секунду, поступающих в Loki. Показывает общую нагрузку.
- **Error Rate:** Количество логов с уровнем `error`, `crit`, `fatal` в секунду. Важный показатель для отслеживания проблем.
- **Loggate Goroutines:** Количество активных горутин в приложении `loggate`. Резкий рост может указывать на утечки или зависания.
- **Loggate Memory (Alloc):** Объем памяти, выделенный приложением `loggate`. Помогает отслеживать утечки памяти.
- **Log Volume by Level:** График, показывающий распределение логов по уровням (INFO, WARN, ERROR).
- **Logs:** Интерактивная панель для просмотра и поиска логов в реальном времени.

**Ручная проверка:**

- **Prometheus:** Перейдите на `http://localhost:9090/targets`, чтобы убедиться, что все сервисы успешно опрашиваются.
- **Grafana Explore:** Используйте эту вкладку для написания произвольных LogQL-запросов к Loki. Например, найти все логи от `auth-service` с ошибками:
  ```logql
  {docker_service="loggate-service", service="auth-service", level="ERROR"}
  ```

### 5.3. Управление данными и бэкапы (Loki)

Данные Loki хранятся в Docker-томе `loggate_loki_data`.

#### Резервное копирование (бэкап)

Это простейший "холодный" способ бэкапа.

1.  **Остановите сервисы, которые пишут в Loki**, чтобы гарантировать целостность данных:
    ```bash
    docker-compose stop loki promtail
    ```
2.  **Найдите путь к тому на хост-машине:**
    ```bash
    docker volume inspect loggate_loki_data
    ```
    В выводе найдите поле `"Mountpoint"`, например `/var/lib/docker/volumes/loggate_loki_data/_data`.
3.  **Создайте архив с данными:**

    ```bash
    # Замените путь на ваш
    TAR_PATH="/var/lib/docker/volumes/loggate_loki_data/_data"
    BACKUP_FILE="loki-backup-$(date +%F).tar.gz"

    tar -czvf "$BACKUP_FILE" -C "$TAR_PATH" .
    ```

    Этот архив можно переместить в безопасное хранилище.

4.  **Запустите сервисы обратно:**
    ```bash
    docker-compose start loki promtail
    ```

#### Очистка старых данных (Retention)

Loki может автоматически удалять старые данные. Это настраивается в `loki/loki-config.yaml`. Добавьте секцию `limits_config`:

```yaml
# loki/loki-config.yaml

auth_enabled: false
server:
  http_listen_port: 3100

# Добавьте эту секцию
limits_config:
  retention_period: 336h # 14 дней (14 * 24h)

common:
  # ... остальная конфигурация
```

После внесения изменений перезапустите Loki: `docker-compose restart loki`.

### 5.4. Дополнительные полезные команды

- **Получить shell внутри контейнера** (для отладки):

  ```bash
  # Для loggate
  docker-compose exec loggate-service /bin/sh
  # Для loki
  docker-compose exec loki /bin/sh
  ```

- **Проверить, слушает ли loggate UDP порт:**
  Отправьте тестовое сообщение с помощью `netcat` (`nc`).

  ```bash
  echo '{"service": "test", "level": "INFO", "message": "hello from netcat"}' | nc -u -w0 127.0.0.1 10514
  ```

  После этого вы должны увидеть это сообщение в логах `loggate` и в Grafana.

- **Перезагрузка конфигурации Prometheus без перезапуска:**
  Если в `prometheus.yaml` были внесены изменения:
  ```bash
  curl -X POST http://localhost:9090/-/reload
  ```
  _Это работает, потому что в `docker-compose.yaml` для Prometheus указан флаг `--web.enable-lifecycle`._
